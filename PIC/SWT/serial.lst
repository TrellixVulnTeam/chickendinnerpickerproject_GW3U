CCS PCD C Compiler, Version 5.015, 5967               27-Oct-18 02:49

               Filename:   C:\Users\asus\Documents\GitHub\chickendinnerpickerproject\PIC\SWT\serial.lst

               ROM used:   770 bytes (2%)
                           Largest free fragment is 29946
               RAM used:   151 (2%) at main() level
                           155 (2%) worst case
               Stack size: 128

*
0C00:  GOTO    E72
*
0C50:  GOTO    E40
.................... #include <24FJ48GA002.h> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
0DFC:  CLR     32
0DFE:  MOV     #E08,W3
0E00:  ADD     W3,W0,W0
0E02:  TBLRDL.B[W0],W0L
0E04:  CLR.B   1
0E06:  RETURN  
0E08:  DATA    53,79,00
0E0A:  DATA    73,74,00
0E0C:  DATA    65,6D,00
0E0E:  DATA    20,52,00
0E10:  DATA    65,61,00
0E12:  DATA    64,79,00
0E14:  DATA    21,0D,00
0E16:  DATA    0A,00,00
....................  
.................... #list 
....................  
.................... #include "BL_Support.h" 
.................... /*  
....................  * File:    BL_Support.h 
....................  * Author:  Dr.Santi Nuratch 
....................  *          Embedded Intelligence Lab., INC-KMUTT 
....................  * Created on 22 September 2016, 13:14 
....................  */ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... #use delay (internal = 8 MHz, clock = 32MHz) 
.................... #PIN_SELECT U1RX = PIN_B12 //PIN_B14 // 
.................... #PIN_SELECT U1TX = PIN_B13 //PIN_B15 // 
.................... #use rs232 (UART1, BAUD = 9600, XMIT = PIN_B13, RCV = PIN_B12) 
....................  
.................... #define DEVICE_ID   2 
....................  
.................... char array[20] = {}; 
.................... char SM_id = 1; 
.................... int getPackage = 0; 
.................... // char* print_float(float data){ 
.................... // 	int intDist = data / 1; 
.................... //     int dotDist = (((intDist>>15)*-2)+1) * ((data * 1000.0f) - (intDist * 1000)); 
.................... //     char stringFloat[20]; 
.................... //     sprintf(stringFloat, "%d.%d", intDist, dotDist); 
.................... //     return stringFloat; 
.................... // } 
.................... // void print_float(char* stringResult, float data){ 
.................... // 	int intDist = data / 1; 
.................... //     int dotDist = (((intDist>>15)*-2)+1) * ((data * 1000.0f) - (intDist * 1000)); 
.................... //     sprintf(stringResult, "%d.%d", intDist, dotDist); 
.................... // } 
.................... void SM_RxD(int c){ 
.................... 	if (SM_id <= 2){ 
0E18:  MOV.B   814,W0L
0E1A:  SE      W0,W0
0E1C:  CP      W0,#2
0E1E:  BRA     GT,E30
.................... 		if (c == 255){ 
0E20:  MOV     81A,W4
0E22:  XOR     #FF,W4
0E24:  BRA     NZ,E2A
.................... 			SM_id++; 
0E26:  INC.B   0814
.................... 		}else{ 
0E28:  BRA     E2E
.................... 			SM_id = 1; 
0E2A:  MOV.B   #1,W0L
0E2C:  MOV.B   W0L,814
.................... 		} 
.................... 	}else{ 
0E2E:  BRA     E3E
.................... 		putc(c); 
0E30:  MOV.B   81A,W0L
0E32:  BTSC.B  223.1
0E34:  BRA     E32
0E36:  MOV.B   W0L,224
0E38:  CLR.B   225
.................... 		SM_id = 1; 
0E3A:  MOV.B   #1,W0L
0E3C:  MOV.B   W0L,814
.................... 	} 
0E3E:  RETURN  
.................... 	// }else if (SM_id <= 3){ 
.................... 	// 	if (c == DEVICE_ID){ 
.................... 	// 		SM_id++; 
.................... 	// 	} 
.................... 	// }else if (SM_id > 3){ 
.................... 	// 	array[SM_id - 4] = c; 
.................... 	// 	SM_id++; 
.................... 	// 	if (SM_id >= 8){ 
.................... 	// 		getPackage = 1; 
.................... 	// 		SM_id = 1; 
.................... 	// 	} 
.................... 	// } 
.................... } 
.................... #INT_RDA               // receive data interrupt one time per one 
.................... void UART1_Isr() { 
0E40:  PUSH    42
0E42:  PUSH    36
0E44:  PUSH    32
0E46:  MOV     W0,[W15++]
0E48:  MOV     #2,W0
0E4A:  REPEAT  #C
0E4C:  MOV     [W0++],[W15++]
0E4E:  BTSS.B  222.0
0E50:  BRA     E4E
0E52:  MOV     226,W0
0E54:  MOV.B   W0L,818
0E56:  CLR.B   819
....................     int c = getc(); 
.................... 		// putc(c); 
....................     SM_RxD(c); 
0E58:  PUSH    818
0E5A:  POP     81A
0E5C:  CALL    E18
0E60:  BCLR.B  85.3
0E62:  MOV     #1A,W0
0E64:  REPEAT  #C
0E66:  MOV     [--W15],[W0--]
0E68:  MOV     [--W15],W0
0E6A:  POP     32
0E6C:  POP     36
0E6E:  POP     42
0E70:  RETFIE  
.................... } 
.................... void main(){ 
0E72:  MOV     #2780,W15
0E74:  MOV     #27FF,W0
0E76:  MOV     W0,20
0E78:  NOP     
0E7A:  MOV     #4444,W0
0E7C:  MOV     W0,A8
0E7E:  BSET.B  81.7
0E80:  MOV     #46,W0
0E82:  MOV.B   W0L,742
0E84:  MOV     #57,W0
0E86:  MOV.B   W0L,742
0E88:  BCLR.B  742.6
0E8A:  MOV     #3F0C,W0
0E8C:  MOV     W0,6A4
0E8E:  MOV     #300,W0
0E90:  MOV     W0,6CC
0E92:  MOV     #46,W0
0E94:  MOV.B   W0L,742
0E96:  MOV     #57,W0
0E98:  MOV.B   W0L,742
0E9A:  BSET.B  742.6
0E9C:  CLR     744
0E9E:  MOV     #8000,W4
0EA0:  MOV     W4,220
0EA2:  MOV     #400,W4
0EA4:  MOV     W4,222
0EA6:  BSET.B  220.3
0EA8:  MOV     #1A0,W4
0EAA:  MOV     W4,228
0EAC:  MOV.B   #1,W0L
0EAE:  MOV.B   W0L,814
0EB0:  CLR     816
0EB2:  SETM    32C
0EB4:  CLR     800
0EB6:  CLR     802
0EB8:  CLR     804
0EBA:  CLR     806
0EBC:  CLR     808
0EBE:  CLR     80A
0EC0:  CLR     80C
0EC2:  CLR     80E
0EC4:  CLR     810
0EC6:  CLR     812
.................... 	disable_interrupts(GLOBAL); 
0EC8:  BCLR.B  81.7
0ECA:  MOV     #E0,W4
0ECC:  MOV     W4,42
0ECE:  BSET.B  81.7
....................  
....................     clear_interrupt(INT_RDA);   // recommend style coding to confirm everything clear before use 
0ED0:  REPEAT  #3
0ED2:  MOV     226,W0
0ED4:  BCLR.B  85.3
....................     enable_interrupts(INT_RDA); 
0ED6:  BSET.B  95.3
....................  
.................... 	enable_interrupts(GLOBAL); 
0ED8:  BCLR.B  81.7
0EDA:  CLR     42
0EDC:  BSET.B  81.7
....................     printf("System Ready!\r\n"); 
0EDE:  MOV     #0,W1
0EE0:  MOV     W1,W0
0EE2:  CLR.B   1
0EE4:  CALL    DFC
0EE8:  INC     W1,W1
0EEA:  BTSC.B  223.1
0EEC:  BRA     EEA
0EEE:  MOV     W0,224
0EF0:  MOV     #E,W0
0EF2:  CPSGT   W1,W0
0EF4:  BRA     EE0
.................... 	while(TRUE){ 
.................... 		if (getPackage >= 1){ 
0EF6:  MOV     816,W4
0EF8:  CP      W4,#1
0EFA:  BRA     LT,EFE
.................... 			getPackage = 0; 
0EFC:  CLR     816
.................... 			// for(int i = 0; i < 8; i++){ 
.................... 			// 	putc(array[i]); 
.................... 			// } 
.................... 			// float test; 
.................... 			// memcpy(&test, array, sizeof(test)); 
.................... 			// printf("\nresult = %s, %s\n", print_float(test), print_float(test)); 
.................... 		} 
0EFE:  BRA     EF6
.................... 	} 
.................... } 
0F00:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9F7   NOPR NOALTI2C1 IOL1WAY NOOSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
