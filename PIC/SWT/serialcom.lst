CCS PCD C Compiler, Version 5.015, 5967               15-Nov-18 22:04

               Filename:   C:\Users\asus\Documents\GitHub\chickendinnerpickerproject\PIC\SWT\serialcom.lst

               ROM used:   1194 bytes (4%)
                           Largest free fragment is 29522
               RAM used:   162 (2%) at main() level
                           176 (2%) worst case
               Stack size: 128

*
0C00:  GOTO    FA0
*
0C50:  GOTO    E90
.................... #include <24FJ48GA002.h> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
0DFC:  CLR     32
0DFE:  MOV     #E08,W3
0E00:  ADD     W3,W0,W0
0E02:  TBLRDL.B[W0],W0L
0E04:  CLR.B   1
0E06:  RETURN  
0E08:  DATA    64,6F,00
0E0A:  DATA    6E,65,00
0E0C:  DATA    00,00,00
0E0E:  CLR     32
0E10:  MOV     #E1A,W3
0E12:  ADD     W3,W0,W0
0E14:  TBLRDL.B[W0],W0L
0E16:  CLR.B   1
0E18:  RETURN  
0E1A:  DATA    72,65,00
0E1C:  DATA    73,65,00
0E1E:  DATA    6E,64,00
0E20:  DATA    00,00,00
....................  
.................... #list 
....................  
.................... #include "BL_Support.h" 
.................... /*  
....................  * File:    BL_Support.h 
....................  * Author:  Dr.Santi Nuratch 
....................  *          Embedded Intelligence Lab., INC-KMUTT 
....................  * Created on 22 September 2016, 13:14 
....................  */ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... #use delay(internal = 8 MHz, clock = 32MHz) 
....................  
.................... #PIN_SELECT U1RX = PIN_B12 // PIN_B14 // 
.................... #PIN_SELECT U1TX = PIN_B13 // PIN_B15 // 
.................... #use rs232(UART1, BAUD = 9600, XMIT = PIN_B13, RCV = PIN_B12) 
....................  
.................... #PIN_SELECT INT1 = PIN_B5 
.................... #PIN_SELECT INT2 = PIN_B6 
....................  
....................  
.................... #define DEVICE_ID 2 
....................  
.................... long count = 0; 
.................... long direction = 0; 
.................... char array[20] = {}; 
.................... char SM_id = 0; 
.................... int getPackage = 0; 
.................... char command_ID; 
.................... int posi = 0; 
.................... // char* print_float(float data){ 
.................... // 	long intDist = data / 1; 
.................... //     long dotDist = (((intDist>>31)*-2)+1) * ((data * 1000.0f) - (intDist * 
.................... //     1000)); 
.................... //     char stringFloat[20]; 
.................... //     sprintf(stringFloat, "%d.%d", intDist, dotDist); 
.................... //     return stringFloat; 
.................... // } 
.................... // void print_float(char* stringResult, float data){ 
.................... // 	long intDist = data / 1; 
.................... //     long dotDist = (((intDist>>31)*-2)+1) * ((data * 1000.0f) - (intDist * 
.................... //     1000)); 
.................... //     sprintf(stringResult, "%d.%d", intDist, dotDist); 
.................... // } 
....................  
.................... //Encoder Interrupts 
....................  
.................... // 
....................  
....................  
.................... // Communication Routines 
....................  
.................... void SM_RxD(int c) { 
0E22:  MOV     W5,[W15++]
....................   if (getPackage == 0) { 
0E24:  CP0     81E
0E26:  BRA     NZ,E8C
....................     if (SM_id < 2) { 
0E28:  MOV.B   81C,W0L
0E2A:  SE      W0,W0
0E2C:  CP      W0,#2
0E2E:  BRA     GE,E4A
....................       if (c == 255) { 
0E30:  MOV     82E,W4
0E32:  XOR     #FF,W4
0E34:  BRA     NZ,E46
....................         array[SM_id] = c; 
0E36:  MOV.B   81C,W0L
0E38:  SE      W0,W0
0E3A:  MOV     #808,W4
0E3C:  ADD     W0,W4,W5
0E3E:  MOV     82E,W0
0E40:  MOV.B   W0L,[W5+#0]
....................         SM_id++; 
0E42:  INC.B   081C
....................       } else { 
0E44:  BRA     E48
....................         SM_id = 0; 
0E46:  CLR.B   81C
....................       } 
....................     } else if (SM_id == 2) { 
0E48:  BRA     E8C
0E4A:  MOV.B   81C,W0L
0E4C:  SE      W0,W0
0E4E:  CP      W0,#2
0E50:  BRA     NZ,E66
....................       array[SM_id] = c; 
0E52:  MOV.B   81C,W0L
0E54:  SE      W0,W0
0E56:  MOV     #808,W4
0E58:  ADD     W0,W4,W5
0E5A:  MOV     82E,W0
0E5C:  MOV.B   W0L,[W5+#0]
....................       command_ID = c; 
0E5E:  MOV.B   82E,W0L
0E60:  MOV.B   W0L,81D
....................       SM_id++; 
0E62:  INC.B   081C
....................     } else if (SM_id > 2) { 
0E64:  BRA     E8C
0E66:  MOV.B   81C,W0L
0E68:  SE      W0,W0
0E6A:  CP      W0,#2
0E6C:  BRA     LE,E8C
....................       array[SM_id] = c; 
0E6E:  MOV.B   81C,W0L
0E70:  SE      W0,W0
0E72:  MOV     #808,W4
0E74:  ADD     W0,W4,W5
0E76:  MOV     82E,W0
0E78:  MOV.B   W0L,[W5+#0]
....................       if (SM_id >= 8) { 
0E7A:  MOV.B   81C,W0L
0E7C:  SE      W0,W0
0E7E:  CP      W0,#8
0E80:  BRA     LT,E8A
....................         getPackage = 1; 
0E82:  MOV     #1,W4
0E84:  MOV     W4,81E
....................         SM_id = 0; 
0E86:  CLR.B   81C
....................       } else { 
0E88:  BRA     E8C
....................         SM_id++; 
0E8A:  INC.B   081C
....................       } 
....................     } 
....................   } 
0E8C:  MOV     [--W15],W5
0E8E:  RETURN  
.................... } 
....................  
.................... #INT_RDA // receive data interrupt one time per one 
.................... void UART1_Isr() { 
0E90:  PUSH    42
0E92:  PUSH    36
0E94:  PUSH    32
0E96:  MOV     W0,[W15++]
0E98:  MOV     #2,W0
0E9A:  REPEAT  #C
0E9C:  MOV     [W0++],[W15++]
0E9E:  BTSS.B  222.0
0EA0:  BRA     E9E
0EA2:  MOV     226,W0
0EA4:  MOV.B   W0L,82C
0EA6:  CLR.B   82D
....................   int c = getc(); 
....................   // putc(c); 
....................   SM_RxD(c); 
0EA8:  PUSH    82C
0EAA:  POP     82E
0EAC:  CALL    E22
0EB0:  BCLR.B  85.3
0EB2:  MOV     #1A,W0
0EB4:  REPEAT  #C
0EB6:  MOV     [--W15],[W0--]
0EB8:  MOV     [--W15],W0
0EBA:  POP     32
0EBC:  POP     36
0EBE:  POP     42
0EC0:  RETFIE  
.................... } 
....................  
.................... // COMMANDS// 
.................... void setHome() { 
....................   printf("done"); 
*
0EF8:  MOV     #0,W1
0EFA:  MOV     W1,W0
0EFC:  CLR.B   1
0EFE:  CALL    DFC
0F02:  INC     W1,W1
0F04:  BTSC.B  223.1
0F06:  BRA     F04
0F08:  MOV     W0,224
0F0A:  MOV     #3,W0
0F0C:  CPSGT   W1,W0
0F0E:  BRA     EFA
....................   getPackage = 0; 
0F10:  CLR     81E
0F12:  RETURN  
.................... } 
....................  
.................... void setPosAB() { 
....................   printf("done"); 
0F14:  MOV     #0,W1
0F16:  MOV     W1,W0
0F18:  CLR.B   1
0F1A:  CALL    DFC
0F1E:  INC     W1,W1
0F20:  BTSC.B  223.1
0F22:  BRA     F20
0F24:  MOV     W0,224
0F26:  MOV     #3,W0
0F28:  CPSGT   W1,W0
0F2A:  BRA     F16
....................   getPackage = 0; 
0F2C:  CLR     81E
0F2E:  RETURN  
.................... } 
....................  
.................... void setPosZ() { 
....................   printf("done"); 
0F30:  MOV     #0,W1
0F32:  MOV     W1,W0
0F34:  CLR.B   1
0F36:  CALL    DFC
0F3A:  INC     W1,W1
0F3C:  BTSC.B  223.1
0F3E:  BRA     F3C
0F40:  MOV     W0,224
0F42:  MOV     #3,W0
0F44:  CPSGT   W1,W0
0F46:  BRA     F32
....................   getPackage = 0; 
0F48:  CLR     81E
0F4A:  RETURN  
.................... } 
....................  
.................... void gripClose(){ 
....................   printf("done"); 
0F4C:  MOV     #0,W1
0F4E:  MOV     W1,W0
0F50:  CLR.B   1
0F52:  CALL    DFC
0F56:  INC     W1,W1
0F58:  BTSC.B  223.1
0F5A:  BRA     F58
0F5C:  MOV     W0,224
0F5E:  MOV     #3,W0
0F60:  CPSGT   W1,W0
0F62:  BRA     F4E
....................   getPackage = 0; 
0F64:  CLR     81E
0F66:  RETURN  
.................... } 
....................  
.................... void gripOpen(){ 
....................   printf("done"); 
0F68:  MOV     #0,W1
0F6A:  MOV     W1,W0
0F6C:  CLR.B   1
0F6E:  CALL    DFC
0F72:  INC     W1,W1
0F74:  BTSC.B  223.1
0F76:  BRA     F74
0F78:  MOV     W0,224
0F7A:  MOV     #3,W0
0F7C:  CPSGT   W1,W0
0F7E:  BRA     F6A
....................   getPackage = 0; 
0F80:  CLR     81E
0F82:  RETURN  
.................... } 
....................  
.................... void gripRotate(){ 
....................   printf("done"); 
0F84:  MOV     #0,W1
0F86:  MOV     W1,W0
0F88:  CLR.B   1
0F8A:  CALL    DFC
0F8E:  INC     W1,W1
0F90:  BTSC.B  223.1
0F92:  BRA     F90
0F94:  MOV     W0,224
0F96:  MOV     #3,W0
0F98:  CPSGT   W1,W0
0F9A:  BRA     F86
....................   getPackage = 0; 
0F9C:  CLR     81E
0F9E:  RETURN  
.................... } 
....................  
.................... int sumCheck() { 
*
0EC2:  CLR     824
0EC4:  MOV.B   810,W0L
0EC6:  SE      W0,W0
0EC8:  MOV     W0,826
....................   int sum = 0; 
....................   int checksum = array[8]; 
....................   for (int i = 0; i < 7; i++) { 
0ECA:  CLR     828
0ECC:  MOV     828,W4
0ECE:  CP      W4,#7
0ED0:  BRA     GE,EE4
....................     sum = sum + array[i]; 
0ED2:  MOV     #808,W4
0ED4:  MOV     828,W3
0ED6:  ADD     W3,W4,W0
0ED8:  MOV     W0,W4
0EDA:  MOV.B   [W4],W0L
0EDC:  SE      W0,W0
0EDE:  ADD     824
0EE0:  INC     0828
0EE2:  BRA     ECC
....................   } 
....................   if (sum == checksum) { 
0EE4:  MOV     824,W0
0EE6:  CP      826
0EE8:  BRA     NZ,EF2
....................     return 1; 
0EEA:  MOV     #1,W4
0EEC:  MOV     W4,0
0EEE:  BRA     EF6
....................   } else { 
0EF0:  BRA     EF6
....................     return 0; 
0EF2:  CLR     0
0EF4:  BRA     EF6
....................   } 
0EF6:  RETURN  
.................... } 
....................  
.................... // 
.................... void main() { 
*
0FA0:  MOV     #2780,W15
0FA2:  MOV     #27FF,W0
0FA4:  MOV     W0,20
0FA6:  NOP     
0FA8:  MOV     #4444,W0
0FAA:  MOV     W0,A8
0FAC:  BSET.B  81.7
0FAE:  MOV     #46,W0
0FB0:  MOV.B   W0L,742
0FB2:  MOV     #57,W0
0FB4:  MOV.B   W0L,742
0FB6:  BCLR.B  742.6
0FB8:  MOV     #53F,W0
0FBA:  MOV     W0,680
0FBC:  MOV     #3F06,W0
0FBE:  MOV     W0,682
0FC0:  MOV     #3F0C,W0
0FC2:  MOV     W0,6A4
0FC4:  MOV     #300,W0
0FC6:  MOV     W0,6CC
0FC8:  MOV     #46,W0
0FCA:  MOV.B   W0L,742
0FCC:  MOV     #57,W0
0FCE:  MOV.B   W0L,742
0FD0:  BSET.B  742.6
0FD2:  CLR     744
0FD4:  MOV     #8000,W4
0FD6:  MOV     W4,220
0FD8:  MOV     #400,W4
0FDA:  MOV     W4,222
0FDC:  BSET.B  220.3
0FDE:  MOV     #1A0,W4
0FE0:  MOV     W4,228
0FE2:  CLR     800
0FE4:  CLR     802
0FE6:  CLR     804
0FE8:  CLR     806
0FEA:  CLR.B   81C
0FEC:  CLR     81E
0FEE:  CLR     820
0FF0:  SETM    32C
0FF2:  CLR     808
0FF4:  CLR     80A
0FF6:  CLR     80C
0FF8:  CLR     80E
0FFA:  CLR     810
0FFC:  CLR     812
0FFE:  CLR     814
1000:  CLR     816
1002:  CLR     818
1004:  CLR     81A
....................   disable_interrupts(GLOBAL); 
1006:  BCLR.B  81.7
1008:  MOV     #E0,W4
100A:  MOV     W4,42
100C:  BSET.B  81.7
....................  
....................   clear_interrupt( 
....................       INT_RDA); // recommend style coding to confirm everything clear before use 
100E:  REPEAT  #3
1010:  MOV     226,W0
1012:  BCLR.B  85.3
....................   enable_interrupts(INT_RDA); 
1014:  BSET.B  95.3
....................  
....................   enable_interrupts(GLOBAL); 
1016:  BCLR.B  81.7
1018:  CLR     42
101A:  BSET.B  81.7
....................   // printf("System Ready!\r\n"); 
....................   while (TRUE) { 
....................     if (getPackage >= 1) { 
101C:  MOV     81E,W4
101E:  CP      W4,#1
1020:  BRA     LT,10A6
....................       int received = sumCheck(); 
1022:  CALL    EC2
1026:  MOV     W0,822
....................       if (!received) { 
1028:  CP0     822
102A:  BRA     NZ,1048
....................         printf("resend"); 
102C:  MOV     #0,W1
102E:  MOV     W1,W0
1030:  CLR.B   1
1032:  CALL    E0E
1036:  INC     W1,W1
1038:  BTSC.B  223.1
103A:  BRA     1038
103C:  MOV     W0,224
103E:  MOV     #5,W0
1040:  CPSGT   W1,W0
1042:  BRA     102E
....................         getPackage = 0; 
1044:  CLR     81E
....................       } else { 
1046:  BRA     10A6
....................         switch (array[2]) { 
1048:  MOV.B   80A,W0L
104A:  CLR.B   1
104C:  XOR     #0,W0
104E:  BRA     Z,1066
1050:  XOR     #1,W0
1052:  BRA     Z,106C
1054:  XOR     #3,W0
1056:  BRA     Z,1072
1058:  XOR     #1,W0
105A:  BRA     Z,1078
105C:  XOR     #7,W0
105E:  BRA     Z,107E
1060:  XOR     #1,W0
1062:  BRA     Z,1084
1064:  BRA     108A
....................         case 0: 
....................           setHome(); 
1066:  CALL    EF8
....................           break; 
106A:  BRA     10A6
....................         case 1: 
....................           setPosAB(); 
106C:  CALL    F14
....................           break; 
1070:  BRA     10A6
....................         case 2: 
....................           setPosZ(); 
1072:  CALL    F30
....................           break; 
1076:  BRA     10A6
....................         case 3: 
....................           gripClose(); 
1078:  CALL    F4C
....................           break; 
107C:  BRA     10A6
....................         case 4: 
....................           gripOpen(); 
107E:  CALL    F68
....................           break; 
1082:  BRA     10A6
....................         case 5: 
....................           gripRotate(); 
1084:  CALL    F84
....................           break; 
1088:  BRA     10A6
....................         default: 
....................           printf("resend"); 
108A:  MOV     #0,W1
108C:  MOV     W1,W0
108E:  CLR.B   1
1090:  CALL    E0E
1094:  INC     W1,W1
1096:  BTSC.B  223.1
1098:  BRA     1096
109A:  MOV     W0,224
109C:  MOV     #5,W0
109E:  CPSGT   W1,W0
10A0:  BRA     108C
....................           getPackage = 0; 
10A2:  CLR     81E
....................           break; 
10A4:  BRA     10A6
....................         } 
....................       } 
....................     } 
10A6:  BRA     101C
....................   } 
.................... } 
10A8:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9F7   NOPR NOALTI2C1 IOL1WAY NOOSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
