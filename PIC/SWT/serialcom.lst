CCS PCD C Compiler, Version 5.015, 5967               16-Nov-18 19:35

               Filename:   C:\Users\asus\Documents\GitHub\chickendinnerpickerproject\PIC\SWT\serialcom.lst

               ROM used:   1878 bytes (6%)
                           Largest free fragment is 28838
               RAM used:   170 (2%) at main() level
                           190 (2%) worst case
               Stack size: 128

*
0C00:  GOTO    11FE
*
0C24:  GOTO    E22
*
0C50:  GOTO    F02
*
0C74:  GOTO    E48
*
0C98:  GOTO    E6E
.................... #include <24FJ48GA002.h> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
0DFC:  CLR     32
0DFE:  MOV     #E08,W3
0E00:  ADD     W3,W0,W0
0E02:  TBLRDL.B[W0],W0L
0E04:  CLR.B   1
0E06:  RETURN  
0E08:  DATA    64,6F,00
0E0A:  DATA    6E,65,00
0E0C:  DATA    00,00,00
0E0E:  CLR     32
0E10:  MOV     #E1A,W3
0E12:  ADD     W3,W0,W0
0E14:  TBLRDL.B[W0],W0L
0E16:  CLR.B   1
0E18:  RETURN  
0E1A:  DATA    72,65,00
0E1C:  DATA    73,65,00
0E1E:  DATA    6E,64,00
0E20:  DATA    00,00,00
....................  
.................... #list 
....................  
.................... #include "BL_Support.h" 
.................... /*  
....................  * File:    BL_Support.h 
....................  * Author:  Dr.Santi Nuratch 
....................  *          Embedded Intelligence Lab., INC-KMUTT 
....................  * Created on 22 September 2016, 13:14 
....................  */ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... #use delay(internal = 8 MHz, clock = 32MHz) 
*
0F42:  CP0     W0
0F44:  BTSC.B  42.1
0F46:  BRA     F50
0F48:  REPEAT  #3E7B
0F4A:  NOP     
0F4C:  DEC     W0,W0
0F4E:  BRA     NZ,F48
0F50:  RETURN  
....................  
.................... #PIN_SELECT U1RX = PIN_B12 // PIN_B14 // 
.................... #PIN_SELECT U1TX = PIN_B13 // PIN_B15 // 
.................... #use rs232(UART1, BAUD = 9600, XMIT = PIN_B13, RCV = PIN_B12) 
....................  
.................... #define DEVICE_ID 2 
.................... #define limitSw_x PIN_B8        // 
.................... #define limitSw_y PIN_A2        // 
.................... #define limitSw_z PIN_A4        // 
.................... #define Motor_Bp PIN_B10        // Pin output is connected to DXI0  (PWM) 
.................... #define Motor_Br PIN_B2         // Pin output is connected to DX02 
.................... #define Motor_Bl PIN_B3         // Pin output is connected to DX03 
.................... #define Motor_Ap PIN_B4         // Pin output is connected to DX03 
.................... #define Motor_Ar PIN_A0         // Pin output is connected to DX03 
.................... #define Motor_Al PIN_A1         // Pin output is connected to DX03 
.................... #define Motor_Zp PIN_B14        // Pin output is connected to DX03 
.................... #define Motor_Zr PIN_B15        // Pin output is connected to DX03 
.................... #define Motor_Zl PIN_B9         // Pin output is connected to DX03 
.................... #define Encode_A PIN_B7         // Pin output is connected to DX03 
.................... #define Encode_B PIN_B6         // Pin output is connected to DX03 
.................... #define Encode_Z PIN_B5         // Pin output is connected to DX03 
.................... #define servo_r PIN_B0          // servo 270 
.................... #define servo_l PIN_B1          // servo 180 
....................  
.................... #PIN_SELECT OC1 = Motor_Bp 
.................... #PIN_SELECT OC2 = Motor_Ap 
.................... #PIN_SELECT OC3 = Motor_Zp 
.................... #PIN_SELECT OC4 = servo_r 
.................... #PIN_SELECT OC5 = servo_l 
.................... #PIN_SELECT INT1 = Encode_B 
.................... #PIN_SELECT INT2 = Encode_Z 
....................  
....................  
.................... // long count = 0; 
.................... long count_a = 0; 
.................... long count_b = 0; 
.................... long count_z = 0; 
.................... long posi = 0; 
.................... int direction = 0; 
.................... char array[20] = {}; 
.................... char SM_id = 0; 
.................... int getPackage = 0; 
.................... char command_ID; 
.................... // char* print_float(float data){ 
.................... //    long intDist = data / 1; 
.................... //     long dotDist = (((intDist>>31)*-2)+1) * ((data * 1000.0f) - (intDist * 
.................... //     1000)); 
.................... //     char stringFloat[20]; 
.................... //     sprintf(stringFloat, "%d.%d", intDist, dotDist); 
.................... //     return stringFloat; 
.................... // } 
.................... // void print_float(char* stringResult, float data){ 
.................... //    long intDist = data / 1; 
.................... //     long dotDist = (((intDist>>31)*-2)+1) * ((data * 1000.0f) - (intDist * 
.................... //     1000)); 
.................... //     sprintf(stringResult, "%d.%d", intDist, dotDist); 
.................... // } 
....................  
.................... //Encoder Interrupts 
.................... #INT_EXT0 
.................... void INT_EXT_INPUT0(void) { 
*
0E22:  PUSH    42
0E24:  PUSH    36
0E26:  PUSH    32
0E28:  MOV     W0,[W15++]
0E2A:  MOV     #2,W0
0E2C:  REPEAT  #C
0E2E:  MOV     [W0++],[W15++]
....................       count_a++; 
0E30:  INC     0800
0E32:  BTSC.B  42.1
0E34:  INC     0802
.................... } 
....................  
0E36:  BCLR.B  84.0
0E38:  MOV     #1A,W0
0E3A:  REPEAT  #C
0E3C:  MOV     [--W15],[W0--]
0E3E:  MOV     [--W15],W0
0E40:  POP     32
0E42:  POP     36
0E44:  POP     42
0E46:  RETFIE  
.................... #INT_EXT1 
.................... void INT_EXT_INPUT1(void) { 
0E48:  PUSH    42
0E4A:  PUSH    36
0E4C:  PUSH    32
0E4E:  MOV     W0,[W15++]
0E50:  MOV     #2,W0
0E52:  REPEAT  #C
0E54:  MOV     [W0++],[W15++]
....................       count_b++; 
0E56:  INC     0804
0E58:  BTSC.B  42.1
0E5A:  INC     0806
.................... } 
....................  
0E5C:  BCLR.B  86.4
0E5E:  MOV     #1A,W0
0E60:  REPEAT  #C
0E62:  MOV     [--W15],[W0--]
0E64:  MOV     [--W15],W0
0E66:  POP     32
0E68:  POP     36
0E6A:  POP     42
0E6C:  RETFIE  
.................... #INT_EXT2 
.................... void INT_EXT_INPUT2(void) { 
0E6E:  PUSH    42
0E70:  PUSH    36
0E72:  PUSH    32
0E74:  MOV     W0,[W15++]
0E76:  MOV     #2,W0
0E78:  REPEAT  #C
0E7A:  MOV     [W0++],[W15++]
....................       count_z++; 
0E7C:  INC     0808
0E7E:  BTSC.B  42.1
0E80:  INC     080A
0E82:  BCLR.B  87.5
0E84:  MOV     #1A,W0
0E86:  REPEAT  #C
0E88:  MOV     [--W15],[W0--]
0E8A:  MOV     [--W15],W0
0E8C:  POP     32
0E8E:  POP     36
0E90:  POP     42
0E92:  RETFIE  
.................... } 
....................  
.................... void Init_Interrupts() { 
.................... 	enable_interrupts( INT_EXT0 ); 
*
0F34:  BSET.B  94.0
....................     ext_int_edge( 0, L_TO_H ); // Rising Edge 
0F36:  BCLR.B  82.0
.................... 	enable_interrupts( INT_EXT1 ); 
0F38:  BSET.B  96.4
....................     ext_int_edge( 1, L_TO_H ); // Rising Edge 
0F3A:  BCLR.B  82.1
.................... 	enable_interrupts( INT_EXT2 ); 
0F3C:  BSET.B  97.5
....................     ext_int_edge( 2, L_TO_H ); // Rising Edge 
0F3E:  BCLR.B  82.2
0F40:  RETURN  
.................... } 
....................  
....................  
.................... // 
....................  
....................  
.................... // Communication Routines 
....................  
.................... void SM_RxD(int c) { 
*
0E94:  MOV     W5,[W15++]
....................   if (getPackage == 0) { 
0E96:  CP0     828
0E98:  BRA     NZ,EFE
....................     if (SM_id < 2) { 
0E9A:  MOV.B   826,W0L
0E9C:  SE      W0,W0
0E9E:  CP      W0,#2
0EA0:  BRA     GE,EBC
....................       if (c == 255) { 
0EA2:  MOV     83C,W4
0EA4:  XOR     #FF,W4
0EA6:  BRA     NZ,EB8
....................         array[SM_id] = c; 
0EA8:  MOV.B   826,W0L
0EAA:  SE      W0,W0
0EAC:  MOV     #812,W4
0EAE:  ADD     W0,W4,W5
0EB0:  MOV     83C,W0
0EB2:  MOV.B   W0L,[W5+#0]
....................         SM_id++; 
0EB4:  INC.B   0826
....................       } else { 
0EB6:  BRA     EBA
....................         SM_id = 0; 
0EB8:  CLR.B   826
....................       } 
....................     } else if (SM_id == 2) { 
0EBA:  BRA     EFE
0EBC:  MOV.B   826,W0L
0EBE:  SE      W0,W0
0EC0:  CP      W0,#2
0EC2:  BRA     NZ,ED8
....................       array[SM_id] = c; 
0EC4:  MOV.B   826,W0L
0EC6:  SE      W0,W0
0EC8:  MOV     #812,W4
0ECA:  ADD     W0,W4,W5
0ECC:  MOV     83C,W0
0ECE:  MOV.B   W0L,[W5+#0]
....................       command_ID = c; 
0ED0:  MOV.B   83C,W0L
0ED2:  MOV.B   W0L,827
....................       SM_id++; 
0ED4:  INC.B   0826
....................     } else if (SM_id > 2) { 
0ED6:  BRA     EFE
0ED8:  MOV.B   826,W0L
0EDA:  SE      W0,W0
0EDC:  CP      W0,#2
0EDE:  BRA     LE,EFE
....................       array[SM_id] = c; 
0EE0:  MOV.B   826,W0L
0EE2:  SE      W0,W0
0EE4:  MOV     #812,W4
0EE6:  ADD     W0,W4,W5
0EE8:  MOV     83C,W0
0EEA:  MOV.B   W0L,[W5+#0]
....................       if (SM_id >= 8) { 
0EEC:  MOV.B   826,W0L
0EEE:  SE      W0,W0
0EF0:  CP      W0,#8
0EF2:  BRA     LT,EFC
....................         getPackage = 1; 
0EF4:  MOV     #1,W4
0EF6:  MOV     W4,828
....................         SM_id = 0; 
0EF8:  CLR.B   826
....................       } else { 
0EFA:  BRA     EFE
....................         SM_id++; 
0EFC:  INC.B   0826
....................       } 
....................     } 
....................   } 
0EFE:  MOV     [--W15],W5
0F00:  RETURN  
.................... } 
....................  
.................... #INT_RDA // receive data interrupt one time per one 
.................... void UART1_Isr() { 
0F02:  PUSH    42
0F04:  PUSH    36
0F06:  PUSH    32
0F08:  MOV     W0,[W15++]
0F0A:  MOV     #2,W0
0F0C:  REPEAT  #C
0F0E:  MOV     [W0++],[W15++]
0F10:  BTSS.B  222.0
0F12:  BRA     F10
0F14:  MOV     226,W0
0F16:  MOV.B   W0L,83A
0F18:  CLR.B   83B
....................   int c = getc(); 
....................   // putc(c); 
....................   SM_RxD(c); 
0F1A:  PUSH    83A
0F1C:  POP     83C
0F1E:  CALL    E94
0F22:  BCLR.B  85.3
0F24:  MOV     #1A,W0
0F26:  REPEAT  #C
0F28:  MOV     [--W15],[W0--]
0F2A:  MOV     [--W15],W0
0F2C:  POP     32
0F2E:  POP     36
0F30:  POP     42
0F32:  RETFIE  
.................... } 
....................  
.................... //Motor 
.................... void Motor_z(int u){ 
*
0FDC:  MOV     W5,[W15++]
....................   if (u > 100)u = 100; 
0FDE:  MOV     82C,W4
0FE0:  MOV     #64,W3
0FE2:  CP      W3,W4
0FE4:  BRA     GE,FEA
0FE6:  MOV     #64,W4
0FE8:  MOV     W4,82C
....................   if (u < -100)u = -100; 
0FEA:  MOV     82C,W4
0FEC:  MOV     #FF9C,W3
0FEE:  CP      W3,W4
0FF0:  BRA     LE,FF6
0FF2:  MOV     #FF9C,W4
0FF4:  MOV     W4,82C
....................   if(u>0){ 
0FF6:  MOV     82C,W4
0FF8:  CP      W4,#0
0FFA:  BRA     LE,1010
....................     output_bit(Motor_Zr,0); 
0FFC:  BCLR.B  2CD.7
0FFE:  BCLR.B  2C9.7
....................     output_bit(Motor_Zl,1); 
1000:  BSET.B  2CD.1
1002:  BCLR.B  2C9.1
....................     direction = 0; 
1004:  CLR     810
....................     set_pwm_duty(3, (int)(2 * u)); 
1006:  MOV     82C,W4
1008:  MUL.UU  W4,#2,W0
100A:  MOV     W0,W5
100C:  MOV     W5,18C
....................   } 
100E:  BRA     1044
....................   else if(u<0) { 
1010:  MOV     82C,W4
1012:  CP      W4,#0
1014:  BRA     GE,1032
....................     output_bit(Motor_Zr,1); 
1016:  BSET.B  2CD.7
1018:  BCLR.B  2C9.7
....................     output_bit(Motor_Zl,0); 
101A:  BCLR.B  2CD.1
101C:  BCLR.B  2C9.1
....................     direction = 1; 
101E:  MOV     #1,W4
1020:  MOV     W4,810
....................     set_pwm_duty(3, (int)(2 * -u)); 
1022:  MOV     #0,W4
1024:  MOV     82C,W3
1026:  SUB     W4,W3,W0
1028:  MOV     W0,W4
102A:  MUL.UU  W4,#2,W0
102C:  MOV     W0,W5
102E:  MOV     W5,18C
....................   }else{ 
1030:  BRA     1044
....................     output_bit(Motor_Zr,1); 
1032:  BSET.B  2CD.7
1034:  BCLR.B  2C9.7
....................     output_bit(Motor_Zl,1); 
1036:  BSET.B  2CD.1
1038:  BCLR.B  2C9.1
....................     set_pwm_duty(3, (int)(100)); 
103A:  MOV     #64,W4
103C:  MOV     W4,18C
....................     delay_ms(100); 
103E:  MOV     #64,W0
1040:  CALL    F42
....................   } 
1044:  MOV     [--W15],W5
1046:  RETURN  
.................... } 
....................  
.................... void Motor_A(int u){ 
1048:  MOV     W5,[W15++]
....................   if (u > 100)u = 100; 
104A:  MOV     82C,W4
104C:  MOV     #64,W3
104E:  CP      W3,W4
1050:  BRA     GE,1056
1052:  MOV     #64,W4
1054:  MOV     W4,82C
....................   if (u < -100)u = -100; 
1056:  MOV     82C,W4
1058:  MOV     #FF9C,W3
105A:  CP      W3,W4
105C:  BRA     LE,1062
105E:  MOV     #FF9C,W4
1060:  MOV     W4,82C
....................   if(u>0){ 
1062:  MOV     82C,W4
1064:  CP      W4,#0
1066:  BRA     LE,107C
....................     output_bit(Motor_Ar,1); 
1068:  BSET.B  2C4.0
106A:  BCLR.B  2C0.0
....................     output_bit(Motor_Al,0); 
106C:  BCLR.B  2C4.1
106E:  BCLR.B  2C0.1
....................     direction = 0; 
1070:  CLR     810
....................     set_pwm_duty(2, (int)(2 * u)); 
1072:  MOV     82C,W4
1074:  MUL.UU  W4,#2,W0
1076:  MOV     W0,W5
1078:  MOV     W5,186
....................   } 
107A:  BRA     10B0
....................   else if(u<0) { 
107C:  MOV     82C,W4
107E:  CP      W4,#0
1080:  BRA     GE,109E
....................     output_bit(Motor_Ar,0); 
1082:  BCLR.B  2C4.0
1084:  BCLR.B  2C0.0
....................     output_bit(Motor_Al,1); 
1086:  BSET.B  2C4.1
1088:  BCLR.B  2C0.1
....................     direction = 1; 
108A:  MOV     #1,W4
108C:  MOV     W4,810
....................     set_pwm_duty(2, (int)(2 * -u)); 
108E:  MOV     #0,W4
1090:  MOV     82C,W3
1092:  SUB     W4,W3,W0
1094:  MOV     W0,W4
1096:  MUL.UU  W4,#2,W0
1098:  MOV     W0,W5
109A:  MOV     W5,186
....................   }else{ 
109C:  BRA     10B0
....................     output_bit(Motor_Ar,1); 
109E:  BSET.B  2C4.0
10A0:  BCLR.B  2C0.0
....................     output_bit(Motor_Al,1); 
10A2:  BSET.B  2C4.1
10A4:  BCLR.B  2C0.1
....................     set_pwm_duty(2, (int)(100)); 
10A6:  MOV     #64,W4
10A8:  MOV     W4,186
....................     delay_ms(100); 
10AA:  MOV     #64,W0
10AC:  CALL    F42
....................   } 
10B0:  MOV     [--W15],W5
10B2:  RETURN  
.................... } 
....................  
.................... void Motor_B(int u){ 
10B4:  MOV     W5,[W15++]
....................   if (u > 100)u = 100; 
10B6:  MOV     82C,W4
10B8:  MOV     #64,W3
10BA:  CP      W3,W4
10BC:  BRA     GE,10C2
10BE:  MOV     #64,W4
10C0:  MOV     W4,82C
....................   if (u < -100)u = -100; 
10C2:  MOV     82C,W4
10C4:  MOV     #FF9C,W3
10C6:  CP      W3,W4
10C8:  BRA     LE,10CE
10CA:  MOV     #FF9C,W4
10CC:  MOV     W4,82C
....................   if(u>0){ 
10CE:  MOV     82C,W4
10D0:  CP      W4,#0
10D2:  BRA     LE,10E8
....................     output_bit(Motor_Br,1); 
10D4:  BSET.B  2CC.2
10D6:  BCLR.B  2C8.2
....................     output_bit(Motor_Bl,0); 
10D8:  BCLR.B  2CC.3
10DA:  BCLR.B  2C8.3
....................     direction = 0; 
10DC:  CLR     810
....................     set_pwm_duty(1, (int)(2 * u)); 
10DE:  MOV     82C,W4
10E0:  MUL.UU  W4,#2,W0
10E2:  MOV     W0,W5
10E4:  MOV     W5,180
....................   } 
10E6:  BRA     111C
....................   else if(u<0) { 
10E8:  MOV     82C,W4
10EA:  CP      W4,#0
10EC:  BRA     GE,110A
....................     output_bit(Motor_Br,0); 
10EE:  BCLR.B  2CC.2
10F0:  BCLR.B  2C8.2
....................     output_bit(Motor_Bl,1); 
10F2:  BSET.B  2CC.3
10F4:  BCLR.B  2C8.3
....................     direction = 1; 
10F6:  MOV     #1,W4
10F8:  MOV     W4,810
....................     set_pwm_duty(1, (int)(2 * -u)); 
10FA:  MOV     #0,W4
10FC:  MOV     82C,W3
10FE:  SUB     W4,W3,W0
1100:  MOV     W0,W4
1102:  MUL.UU  W4,#2,W0
1104:  MOV     W0,W5
1106:  MOV     W5,180
....................   }else{ 
1108:  BRA     111C
....................     output_bit(Motor_Br,1); 
110A:  BSET.B  2CC.2
110C:  BCLR.B  2C8.2
....................     output_bit(Motor_Bl,1); 
110E:  BSET.B  2CC.3
1110:  BCLR.B  2C8.3
....................     set_pwm_duty(1, (int)(100)); 
1112:  MOV     #64,W4
1114:  MOV     W4,180
....................     delay_ms(100); 
1116:  MOV     #64,W0
1118:  CALL    F42
....................   } 
111C:  MOV     [--W15],W5
111E:  RETURN  
.................... } 
.................... // 
.................... // COMMANDS// 
.................... void setHome() { 
1120:  MOV     W5,[W15++]
....................   setup_compare(3, COMPARE_PWM | COMPARE_TIMER3); 
1122:  MOV     #E,W4
1124:  MOV     W4,190
....................     setup_compare(2, COMPARE_PWM | COMPARE_TIMER3); 
1126:  MOV     #E,W4
1128:  MOV     W4,18A
.................... 	setup_compare(1, COMPARE_PWM | COMPARE_TIMER3); 
112A:  MOV     #E,W4
112C:  MOV     W4,184
.................... 	set_pwm_duty(3,0); 
112E:  CLR     18C
.................... 	set_pwm_duty(2,0); 
1130:  CLR     186
....................     set_pwm_duty(1,0); 
1132:  CLR     180
.................... 	do{ 
.................... 		Motor_z(-100); 
1134:  MOV     #FF9C,W4
1136:  MOV     W4,82C
1138:  CALL    FDC
.................... 	}while(input(limitSw_z)==1); 
113C:  BSET.B  2C0.4
113E:  BTSC.B  2C2.4
1140:  BRA     1134
.................... 	Motor_z(0); 
1142:  CLR     82C
1144:  CALL    FDC
.................... 	do{ 
.................... 		Motor_a(-100); 
1148:  MOV     #FF9C,W4
114A:  MOV     W4,82C
114C:  CALL    1048
.................... 		Motor_b(-100); 
1150:  MOV     #FF9C,W4
1152:  MOV     W4,82C
1154:  CALL    10B4
.................... 	}while(input(limitSw_x)==1); 
1158:  BSET.B  2C9.0
115A:  BTSC.B  2CB.0
115C:  BRA     1148
.................... 	Motor_a(0); 
115E:  CLR     82C
1160:  CALL    1048
.................... 	Motor_b(0); 
1164:  CLR     82C
1166:  CALL    10B4
.................... 	do{ 
.................... 		Motor_a(100); 
116A:  MOV     #64,W4
116C:  MOV     W4,82C
116E:  CALL    1048
.................... 		Motor_b(-100); 
1172:  MOV     #FF9C,W4
1174:  MOV     W4,82C
1176:  CALL    10B4
.................... 	}while(input(limitSw_y)==1); 
117A:  BSET.B  2C0.2
117C:  BTSC.B  2C2.2
117E:  BRA     116A
.................... 	Motor_a(0); 
1180:  CLR     82C
1182:  CALL    1048
.................... 	Motor_b(0); 
1186:  CLR     82C
1188:  CALL    10B4
....................   printf("done"); 
118C:  MOV     #0,W1
118E:  MOV     W1,W0
1190:  CLR.B   1
1192:  CALL    DFC
1196:  INC     W1,W1
1198:  BTSC.B  223.1
119A:  BRA     1198
119C:  MOV     W0,224
119E:  MOV     #3,W0
11A0:  CPSGT   W1,W0
11A2:  BRA     118E
....................   getPackage = 0; 
11A4:  CLR     828
11A6:  MOV     [--W15],W5
11A8:  RETURN  
.................... } 
....................  
.................... void setPosAB() { 
....................   printf("done"); 
11AA:  MOV     #0,W1
11AC:  MOV     W1,W0
11AE:  CLR.B   1
11B0:  CALL    DFC
11B4:  INC     W1,W1
11B6:  BTSC.B  223.1
11B8:  BRA     11B6
11BA:  MOV     W0,224
11BC:  MOV     #3,W0
11BE:  CPSGT   W1,W0
11C0:  BRA     11AC
....................   getPackage = 0; 
11C2:  CLR     828
11C4:  RETURN  
.................... } 
....................  
.................... void setPosZ() { 
....................   printf("done"); 
11C6:  MOV     #0,W1
11C8:  MOV     W1,W0
11CA:  CLR.B   1
11CC:  CALL    DFC
11D0:  INC     W1,W1
11D2:  BTSC.B  223.1
11D4:  BRA     11D2
11D6:  MOV     W0,224
11D8:  MOV     #3,W0
11DA:  CPSGT   W1,W0
11DC:  BRA     11C8
....................   getPackage = 0; 
11DE:  CLR     828
11E0:  RETURN  
.................... } 
....................  
.................... void gripClose(){ 
....................   setup_compare(5, COMPARE_PWM | COMPARE_TIMER2); 
*
0F7C:  MOV     #6,W4
0F7E:  MOV     W4,19C
....................   set_pwm_duty(5, 1600); 
0F80:  MOV     #640,W4
0F82:  MOV     W4,198
....................   delay_ms(500); 
0F84:  MOV     #1F4,W0
0F86:  CALL    F42
....................   printf("done"); 
0F8A:  MOV     #0,W1
0F8C:  MOV     W1,W0
0F8E:  CLR.B   1
0F90:  CALL    DFC
0F94:  INC     W1,W1
0F96:  BTSC.B  223.1
0F98:  BRA     F96
0F9A:  MOV     W0,224
0F9C:  MOV     #3,W0
0F9E:  CPSGT   W1,W0
0FA0:  BRA     F8C
....................   getPackage = 0; 
0FA2:  CLR     828
0FA4:  RETURN  
.................... } 
....................  
.................... void gripOpen(){ 
....................   setup_compare(5, COMPARE_PWM | COMPARE_TIMER2); 
*
0F52:  MOV     #6,W4
0F54:  MOV     W4,19C
....................   set_pwm_duty(5, 4800); 
0F56:  MOV     #12C0,W4
0F58:  MOV     W4,198
....................   delay_ms(500); 
0F5A:  MOV     #1F4,W0
0F5C:  CALL    F42
....................   printf("done"); 
0F60:  MOV     #0,W1
0F62:  MOV     W1,W0
0F64:  CLR.B   1
0F66:  CALL    DFC
0F6A:  INC     W1,W1
0F6C:  BTSC.B  223.1
0F6E:  BRA     F6C
0F70:  MOV     W0,224
0F72:  MOV     #3,W0
0F74:  CPSGT   W1,W0
0F76:  BRA     F62
....................   getPackage = 0; 
0F78:  CLR     828
0F7A:  RETURN  
.................... } 
....................  
.................... void gripRotate(){ 
....................   printf("done"); 
*
11E2:  MOV     #0,W1
11E4:  MOV     W1,W0
11E6:  CLR.B   1
11E8:  CALL    DFC
11EC:  INC     W1,W1
11EE:  BTSC.B  223.1
11F0:  BRA     11EE
11F2:  MOV     W0,224
11F4:  MOV     #3,W0
11F6:  CPSGT   W1,W0
11F8:  BRA     11E4
....................   getPackage = 0; 
11FA:  CLR     828
11FC:  RETURN  
.................... } 
....................  
.................... int sumCheck() { 
*
0FA6:  CLR     82C
0FA8:  MOV.B   81A,W0L
0FAA:  SE      W0,W0
0FAC:  MOV     W0,82E
....................   int sum = 0; 
....................   int checksum = array[8]; 
....................   for (int i = 0; i < 7; i++) { 
0FAE:  CLR     830
0FB0:  MOV     830,W4
0FB2:  CP      W4,#7
0FB4:  BRA     GE,FC8
....................     sum = sum + array[i]; 
0FB6:  MOV     #812,W4
0FB8:  MOV     830,W3
0FBA:  ADD     W3,W4,W0
0FBC:  MOV     W0,W4
0FBE:  MOV.B   [W4],W0L
0FC0:  SE      W0,W0
0FC2:  ADD     82C
0FC4:  INC     0830
0FC6:  BRA     FB0
....................   } 
....................   if (sum == checksum) { 
0FC8:  MOV     82C,W0
0FCA:  CP      82E
0FCC:  BRA     NZ,FD6
....................     return 1; 
0FCE:  MOV     #1,W4
0FD0:  MOV     W4,0
0FD2:  BRA     FDA
....................   } else { 
0FD4:  BRA     FDA
....................     return 0; 
0FD6:  CLR     0
0FD8:  BRA     FDA
....................   } 
0FDA:  RETURN  
.................... } 
.................... // 
....................  
.................... // 
.................... void main() { 
*
11FE:  MOV     #2780,W15
1200:  MOV     #27FF,W0
1202:  MOV     W0,20
1204:  NOP     
1206:  MOV     #4444,W0
1208:  MOV     W0,A8
120A:  BSET.B  81.7
120C:  MOV     #46,W0
120E:  MOV.B   W0L,742
1210:  MOV     #57,W0
1212:  MOV.B   W0L,742
1214:  BCLR.B  742.6
1216:  MOV     #63F,W0
1218:  MOV     W0,680
121A:  MOV     #3F05,W0
121C:  MOV     W0,682
121E:  MOV     #3F0C,W0
1220:  MOV     W0,6A4
1222:  MOV     #1615,W0
1224:  MOV     W0,6C0
1226:  MOV     #13,W0
1228:  MOV     W0,6C4
122A:  MOV     #12,W0
122C:  MOV     W0,6CA
122E:  MOV     #300,W0
1230:  MOV     W0,6CC
1232:  MOV     #14,W0
1234:  MOV     W0,6CE
1236:  MOV     #46,W0
1238:  MOV.B   W0L,742
123A:  MOV     #57,W0
123C:  MOV.B   W0L,742
123E:  BSET.B  742.6
1240:  CLR     744
1242:  MOV     #8000,W4
1244:  MOV     W4,220
1246:  MOV     #400,W4
1248:  MOV     W4,222
124A:  BSET.B  220.3
124C:  MOV     #1A0,W4
124E:  MOV     W4,228
1250:  CLR     800
1252:  CLR     802
1254:  CLR     804
1256:  CLR     806
1258:  CLR     808
125A:  CLR     80A
125C:  CLR     80C
125E:  CLR     80E
1260:  CLR     810
1262:  CLR.B   826
1264:  CLR     828
1266:  SETM    32C
1268:  CLR     812
126A:  CLR     814
126C:  CLR     816
126E:  CLR     818
1270:  CLR     81A
1272:  CLR     81C
1274:  CLR     81E
1276:  CLR     820
1278:  CLR     822
127A:  CLR     824
....................   disable_interrupts(GLOBAL); 
127C:  BCLR.B  81.7
127E:  MOV     #E0,W4
1280:  MOV     W4,42
1282:  BSET.B  81.7
....................  
....................   clear_interrupt(INT_RDA); // recommend style coding to confirm everything clear before use 
1284:  REPEAT  #3
1286:  MOV     226,W0
1288:  BCLR.B  85.3
....................  
....................   enable_interrupts(INT_RDA); 
128A:  BSET.B  95.3
....................   Init_Interrupts(); 
128C:  CALL    F34
....................   enable_interrupts(GLOBAL); 
1290:  BCLR.B  81.7
1292:  CLR     42
1294:  BSET.B  81.7
....................   setup_timer3(TMR_INTERNAL | TMR_DIV_BY_8, 200); 
1296:  CLR     112
1298:  MOV     #C8,W4
129A:  MOV     W4,10E
129C:  MOV     #8010,W4
129E:  MOV     W4,112
....................   setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8, 8000); 
12A0:  CLR     110
12A2:  MOV     #1F40,W4
12A4:  MOV     W4,10C
12A6:  MOV     #8010,W4
12A8:  MOV     W4,110
....................   setup_timer1(TMR_INTERNAL | TMR_DIV_BY_8, 6666); 
12AA:  CLR     104
12AC:  MOV     #1A0A,W4
12AE:  MOV     W4,102
12B0:  MOV     #8010,W4
12B2:  MOV     W4,104
....................   gripOpen(); 
12B4:  CALL    F52
....................   delay_ms(1000); 
12B8:  MOV     #3E8,W0
12BA:  CALL    F42
....................   gripClose(); 
12BE:  CALL    F7C
....................   delay_ms(1000); 
12C2:  MOV     #3E8,W0
12C4:  CALL    F42
....................   // printf("System Ready!\r\n"); 
....................   while (TRUE) { 
....................     if (getPackage >= 1) { 
12C8:  MOV     828,W4
12CA:  CP      W4,#1
12CC:  BRA     LT,1352
....................       int received = sumCheck(); 
12CE:  CALL    FA6
12D2:  MOV     W0,82A
....................       if (!received) { 
12D4:  CP0     82A
12D6:  BRA     NZ,12F4
....................         printf("resend"); 
12D8:  MOV     #0,W1
12DA:  MOV     W1,W0
12DC:  CLR.B   1
12DE:  CALL    E0E
12E2:  INC     W1,W1
12E4:  BTSC.B  223.1
12E6:  BRA     12E4
12E8:  MOV     W0,224
12EA:  MOV     #5,W0
12EC:  CPSGT   W1,W0
12EE:  BRA     12DA
....................         getPackage = 0; 
12F0:  CLR     828
....................       } else { 
12F2:  BRA     1352
....................         switch (array[2]) { 
12F4:  MOV.B   814,W0L
12F6:  CLR.B   1
12F8:  XOR     #0,W0
12FA:  BRA     Z,1312
12FC:  XOR     #1,W0
12FE:  BRA     Z,1318
1300:  XOR     #3,W0
1302:  BRA     Z,131E
1304:  XOR     #1,W0
1306:  BRA     Z,1324
1308:  XOR     #7,W0
130A:  BRA     Z,132A
130C:  XOR     #1,W0
130E:  BRA     Z,1330
1310:  BRA     1336
....................         case 0: 
....................           setHome(); 
1312:  CALL    1120
....................           break; 
1316:  BRA     1352
....................         case 1: 
....................           setPosAB(); 
1318:  CALL    11AA
....................           break; 
131C:  BRA     1352
....................         case 2: 
....................           setPosZ(); 
131E:  CALL    11C6
....................           break; 
1322:  BRA     1352
....................         case 3: 
....................           gripClose(); 
1324:  CALL    F7C
....................           break; 
1328:  BRA     1352
....................         case 4: 
....................           gripOpen(); 
132A:  CALL    F52
....................           break; 
132E:  BRA     1352
....................         case 5: 
....................           gripRotate(); 
1330:  CALL    11E2
....................           break; 
1334:  BRA     1352
....................         default: 
....................           printf("resend"); 
1336:  MOV     #0,W1
1338:  MOV     W1,W0
133A:  CLR.B   1
133C:  CALL    E0E
1340:  INC     W1,W1
1342:  BTSC.B  223.1
1344:  BRA     1342
1346:  MOV     W0,224
1348:  MOV     #5,W0
134A:  CPSGT   W1,W0
134C:  BRA     1338
....................           getPackage = 0; 
134E:  CLR     828
....................           break; 
1350:  BRA     1352
....................         } 
....................       } 
....................     } 
1352:  BRA     12C8
....................   } 
.................... } 
1354:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9F7   NOPR NOALTI2C1 IOL1WAY NOOSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
